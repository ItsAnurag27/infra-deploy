name: Complete Infrastructure & Deployment Pipeline

on:
  # push:
  #   branches:
  #     - main
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  actions: read
  security-events: write

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0
  AWS_ROLE_ARN: arn:aws:iam::549363909370:role/oidc-anurag

jobs:
  # ============== TERRAFORM VALIDATION ==============
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}


      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Trivy Filesystem Scan (Full)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          format: json
          output: trivy-report.json
          scanners: vuln,config,secret,license
          severity: CRITICAL,HIGH,MEDIUM,LOW
          ignore-unfixed: true
          skip-dirs: terraform,.github
        continue-on-error: true

      - name: Display Trivy Security Report
        if: always()
        run: |
          echo "Trivy Security Scan Report"
          echo "=============================="
          echo ""
          if [ -f trivy-report.json ]; then
            # Check if report has content
            if [ -s trivy-report.json ]; then
              echo "Vulnerabilities Found:"
              cat trivy-report.json | jq '.' || cat trivy-report.json
            else
              echo "No vulnerabilities detected - Repository is secure!"
            fi
          else
            echo "  Trivy report file not found"
          fi
          echo ""
      - name: Upload Trivy Report as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-report
          path: trivy-report.json

  # ============== TERRAFORM DEPLOY ==============
  terraform-deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    needs: [terraform-validate]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan -out=tfplan -var-file=terraform.tfvars
          terraform show tfplan
      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan
  # ============== SONARQUBE SETUP ==============
  setup-sonarqube:
    name: Setup SonarQube on EC2
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: github.event_name == 'push'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get SonarQube EC2 Public IP
        id: ec2-info
        run: |
          EC2_IP="18.210.3.140"
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ SonarQube EC2 IP: $EC2_IP"
      - name: Install SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.ec2-info.outputs.ec2_ip }} >> ~/.ssh/known_hosts
      - name: Wait for EC2 to be accessible via SSH
        run: |
          echo "‚è≥ Waiting for EC2 to be accessible via SSH..."
          for i in {1..30}; do
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} "echo 'SSH connection successful'"; then
              echo "‚úÖ EC2 is accessible via SSH"
              break
            fi
            echo "Attempt $i/30: Waiting for SSH..."
            sleep 10
          done
      - name: Install Docker, Docker Compose and Run SonarQube
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          
          echo "üì¶ Updating system packages..."
          sudo apt update
          sudo apt upgrade -y
          
          echo "üê≥ Installing Docker..."
          sudo apt install docker.io -y
          echo "‚úÖ Docker installed"
          
          echo "üê≥ Installing Docker Compose..."
          sudo apt install docker-compose -y
          echo "‚úÖ Docker Compose installed"
          
          echo "üë§ Adding ubuntu user to docker group..."
          sudo usermod -aG docker ubuntu
          
          echo "üë§ Adding jenkins user to docker group..."
          sudo usermod -aG docker jenkins || true
          
          echo "üöÄ Enabling and starting Docker service..."
          sudo systemctl enable docker
          sudo systemctl start docker
          
          echo "‚è≥ Waiting for Docker to be ready..."
          sleep 10
          sudo docker run -itd --name sonarqube-server -p 9000:9000 sonarqube:latest
          
          echo "‚è≥ Waiting for SonarQube to initialize (2-5 minutes)..."
          sleep 30
          sudo docker ps | grep sonarqube-server
          
          
          EOF
  # ============== APPLICATION DEPLOYMENT ==============

  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Public IP
        id: ec2-info
        run: |
          echo "üìç Fetching EC2 instance public IP from AWS..."
          EC2_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=cloudnexus-web-server" "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --region ${{ env.AWS_REGION }} \
            --output text)
          
          if [ -z "$EC2_IP" ] || [ "$EC2_IP" == "None" ]; then
            echo "‚ùå Failed to retrieve EC2 public IP. Available instances:"
            aws ec2 describe-instances \
              --filters "Name=instance-state-name,Values=running" \
              --query 'Reservations[].Instances[].[InstanceId,Tags[?Key==`Name`].Value|[0],PublicIpAddress]' \
              --region ${{ env.AWS_REGION }} \
              --output table
            exit 1
          fi
          
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ EC2 Public IP: $EC2_IP"
      - name: Install SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.ec2-info.outputs.ec2_ip }} >> ~/.ssh/known_hosts
      - name: Wait for EC2 to be accessible via SSH
        run: |
          echo "‚è≥ Waiting for EC2 to be accessible via SSH..."
          for i in {1..30}; do
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} "echo 'SSH connection successful'"; then
              echo "‚úÖ EC2 is accessible via SSH"
              break
            fi
            echo "Attempt $i/30: Waiting for SSH..."
            sleep 10
          done
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
            ${{ steps.login-ecr.outputs.registry }}/cn-web:${{ github.sha }}
      - name: Setup Node.js and Generate Code Coverage
        uses: actions/setup-node@v4
        with:
          node-version: 18
      - name: Install Dependencies and Run Tests with Coverage
        working-directory: frontend
        run: |
          echo "üì¶ Installing frontend dependencies..."
          npm install
          echo "üß™ Running unit tests with coverage (excluding integration tests)..."
          echo "üìù Jest Config Check:"
          npx jest --showConfig 2>&1 | head -50
          echo ""
          echo "üîç Running tests..."
          npx jest \
            --coverage \
            --passWithNoTests \
            --testPathIgnorePatterns="__tests__/integration" \
            --collectCoverageFrom="src/**/*.{ts,tsx}" \
            --collectCoverageFrom="!src/**/*.d.ts" \
            --collectCoverageFrom="!src/__tests__/**" \
            --coverageDirectory="coverage" \
            --coverageReporters="lcov" \
            --coverageReporters="json-summary" \
            --coverageReporters="text"
          
          echo ""
          echo "‚úÖ Tests completed"
          echo "üìÇ Checking coverage folder..."
          if [ -d "coverage" ]; then
            echo "‚úÖ Coverage directory found with $(find coverage -type f | wc -l) files:"
            ls -lah coverage/
          else
            echo "‚ùå Coverage directory NOT found"
          fi
        continue-on-error: true
      - name: Verify Coverage Report
        run: |
          echo "üîç Searching for coverage files..."
          find . -name "lcov.info" -type f
          echo ""
          echo "üìä Frontend coverage structure:"
          if [ -d "frontend/coverage" ]; then
            tree -L 2 frontend/coverage 2>/dev/null || ls -laR frontend/coverage
          else
            echo "‚ö†Ô∏è frontend/coverage directory does not exist"
            echo "üìÅ Creating directory for reference..."
            mkdir -p frontend/coverage
          fi
      - name: Upload Code Coverage Report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: code-coverage-report
          path: frontend/coverage/
          retention-days: 30
          if-no-files-found: warn
          compression-level: 6
          overwrite: false
          include-hidden-files: false
      - name: Display Coverage Summary
        if: always()
        run: |
          echo "üìä Coverage Summary Report"
          if [ -f frontend/coverage/coverage-summary.json ]; then
            echo "‚úÖ Summary found:"
            cat frontend/coverage/coverage-summary.json | jq '.total' 2>/dev/null || cat frontend/coverage/coverage-summary.json
          else
            echo "‚ö†Ô∏è Coverage summary not found at frontend/coverage/coverage-summary.json"
            echo "üìÅ Available files:"
            ls -la frontend/coverage/ 2>/dev/null || echo "Coverage directory is empty"
          fi
      - name: Run SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@v2
        env:
          SONAR_TOKEN: ${{ secrets.SONARQUBE_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONARQUBE_HOST_URL }}
        with:
          args: >
            -Dsonar.projectKey=cn-web
            -Dsonar.projectName=CN-Web
            -Dsonar.sources=frontend
            -Dsonar.exclusions=**/node_modules/**,**/dist/**
            -Dsonar.javascript.lcov.reportPaths=frontend/coverage/lcov.info
            -Dsonar.coverage.exclusions=**/node_modules/**,**/__tests__/**,**/dist/**
        continue-on-error: true
      - name: Verify Docker Installation
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "‚è≥ Waiting for Docker installation to complete..."
          max_attempts=30
          attempt=0
          while ! docker --version && [ $attempt -lt $max_attempts ]; do
            echo "Attempt $((attempt+1))/$max_attempts: Docker not ready yet..."
            sleep 10
            attempt=$((attempt+1))
          done
          if docker --version; then
            echo "‚úÖ Docker is installed: $(docker --version)"
          else
            echo "‚ùå Docker installation timeout"
            exit 1
          fi
          EOF
      - name: Pull and Run Docker Image from ECR
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "ÔøΩ Installing AWS CLI..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq awscli 2>/dev/null || sudo apt-get install -y -qq python3-pip && pip3 install -q awscli
          
          echo "ÔøΩüîê Logging in to AWS ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
          echo "üê≥ Pulling Docker image from ECR..."
          docker pull ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
          echo "‚èπÔ∏è Stopping any existing containers..."
          docker stop cn-web-app 2>/dev/null || true
          docker rm cn-web-app 2>/dev/null || true
          echo "üöÄ Starting application from ECR image..."
          docker run -d --name cn-web-app -p 5173:5173 ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
          echo "‚è≥ Waiting for application to be ready..."
          sleep 15
          if docker ps | grep -q cn-web-app; then
            echo "‚úÖ Application started successfully"
            docker ps | grep cn-web-app
          else
            echo "‚ùå Application failed to start"
            docker logs cn-web-app
            exit 1
          fi
          EOF
      - name: Scan Docker Image with Trivy
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "üîç Scanning Docker image for vulnerabilities..."
          
          IMAGE_NAME="${{ steps.login-ecr.outputs.registry }}/cn-web:latest"
          
          echo "üì¶ Scanning image: $IMAGE_NAME"
          echo "‚è≥ This may take a few minutes on first run..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --scanners vuln --severity HIGH,CRITICAL --timeout 10m $IMAGE_NAME || true
          echo "‚úÖ Image scan completed"
          EOF
      - name: Generate Deployment Summary
        id: summary
        run: |
          cat > deployment-summary.txt << EOF
          ================================================
          üéâ DEPLOYMENT COMPLETED SUCCESSFULLY üéâ
          ================================================
          
          üìä INFRASTRUCTURE DETAILS
          ‚îú‚îÄ Region: ${{ env.AWS_REGION }}
          ‚îî‚îÄ Status: Infrastructure deployed via Terraform
          
          üåê APPLICATION ACCESS
          ‚îú‚îÄ Website URL: http://${{ steps.ec2-info.outputs.ec2_ip }}:5173
          ‚îú‚îÄ SSH Access: ssh -i <your-key.pem> ubuntu@${{ steps.ec2-info.outputs.ec2_ip }}
          ‚îî‚îÄ Status: ‚úÖ Running
          
          üìù REPOSITORY
          ‚îú‚îÄ Cloned from: https://github.com/CloudNexus-Org/CN-Web
          ‚îú‚îÄ Branch: main
          ‚îî‚îÄ Location: /home/ubuntu/app/CN-Web
          
          üê≥ CONTAINER STATUS
          ‚îú‚îÄ Docker: ‚úÖ Installed
          ‚îú‚îÄ Docker Compose: ‚úÖ Installed
          ‚îú‚îÄ Application: ‚úÖ Running
          ‚îî‚îÄ Port: 5173
          
          ‚è±Ô∏è  DEPLOYMENT TIME: $(date)
          ================================================
          
          üöÄ NEXT STEPS:
          1. Access your application at: http://${{ steps.ec2-info.outputs.ec2_ip }}:5173
          2. SSH into instance: ssh -i <your-key.pem> ubuntu@${{ steps.ec2-info.outputs.ec2_ip }}
          3. View logs: docker-compose logs -f
          4. Stop application: docker-compose down
          
          ================================================
          EOF
          cat deployment-summary.txt
      - name: Upload Deployment Summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.txt

  # ============== CLEANUP RESOURCES ==============
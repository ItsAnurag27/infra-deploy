name: Complete Infrastructure & Deployment Pipeline

on:
  push:
    branches:
      - main

permissions:
  contents: read
  id-token: write
  actions: read
  security-events: write

env:
  AWS_REGION: us-east-1
  TF_VERSION: 1.6.0
  AWS_ROLE_ARN: arn:aws:iam::549363909370:role/oidc-anurag

jobs:
  # ============== TERRAFORM VALIDATION ==============
  terraform-validate:
    name: Terraform Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}


      - name: Terraform Init
        working-directory: terraform
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: terraform
        run: terraform validate

      - name: Trivy Filesystem Scan (Full)
        uses: aquasecurity/trivy-action@0.24.0
        with:
          scan-type: fs
          scan-ref: .
          format: json
          output: trivy-report.json
          scanners: vuln,config,secret,license
          severity: CRITICAL,HIGH,MEDIUM,LOW
          ignore-unfixed: true
          skip-dirs: terraform,.github
        continue-on-error: true

      - name: Display Trivy Security Report
        if: always()
        run: |
          echo "Trivy Security Scan Report"
          echo "=============================="
          echo ""
          if [ -f trivy-report.json ]; then
            # Check if report has content
            if [ -s trivy-report.json ]; then
              echo "Vulnerabilities Found:"
              cat trivy-report.json | jq '.' || cat trivy-report.json
            else
              echo "No vulnerabilities detected - Repository is secure!"
            fi
          else
            echo "  Trivy report file not found"
          fi
          echo ""

      - name: Upload Trivy Report as Artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-security-report
          path: trivy-report.json

  # ============== TERRAFORM DEPLOY ==============
  terraform-deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [terraform-validate]
    outputs:
      instance_id: ${{ steps.tf-output.outputs.instance_id }}
      elastic_ip: ${{ steps.tf-output.outputs.elastic_ip }}
      ecr_repository_url: ${{ steps.tf-output.outputs.ecr_repository_url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init
        working-directory: terraform
        run: terraform init

      - name: Terraform Plan
        working-directory: terraform
        run: |
          terraform plan -out=tfplan -var-file=terraform.tfvars
          terraform show tfplan

      - name: Terraform Apply
        working-directory: terraform
        run: terraform apply -auto-approve tfplan

      - name: Export Terraform Outputs
        id: tf-output
        working-directory: terraform
        shell: bash
        run: |
          # Extract instance_id from terraform output
          INSTANCE_ID=$(terraform output -raw instance_id 2>&1)
          
          # Remove any debug output and extract just the ID
          INSTANCE_ID=$(echo "$INSTANCE_ID" | grep -oP 'i-[a-z0-9]+' | head -1)
          
          if [ -z "$INSTANCE_ID" ]; then
            echo "Failed to extract instance_id from Terraform output"
            terraform output
            exit 1
          fi
          
          # Extract security_group_id
          SECURITY_GROUP=$(terraform output -raw security_group_id 2>&1 | grep -oP 'sg-[a-z0-9]+' | head -1)
          
          # Extract ECR repository URL (format: account-id.dkr.ecr.region.amazonaws.com/repo-name)
          ECR_REPO=$(terraform output -raw ecr_repository_url 2>&1 | grep -oP '\d+\.dkr\.ecr\.[a-z0-9\-]+\.amazonaws\.com/[a-z0-9\-]+' | head -1)
          
          echo "instance_id=${INSTANCE_ID}" >> "$GITHUB_OUTPUT"
          echo "security_group_id=${SECURITY_GROUP}" >> "$GITHUB_OUTPUT"
          echo "ecr_repository_url=${ECR_REPO}" >> "$GITHUB_OUTPUT"
          echo "‚úÖ Infrastructure deployed successfully - Instance ID: $INSTANCE_ID"

      - name: Wait for EC2 Instance
        run: |
          echo "‚è≥ Waiting for EC2 instance to be running..."
          aws ec2 wait instance-running --instance-ids ${{ steps.tf-output.outputs.instance_id }} --region ${{ env.AWS_REGION }}
          echo "‚úÖ EC2 instance is running"

      - name: Wait for EC2 Status Checks
        run: |
          echo "‚è≥ Waiting for EC2 status checks to pass..."
          aws ec2 wait instance-status-ok --instance-ids ${{ steps.tf-output.outputs.instance_id }} --region ${{ env.AWS_REGION }}
          echo "‚úÖ EC2 status checks passed"

  # ============== SONARQUBE SETUP ==============
  setup-sonarqube:
    name: Setup SonarQube on EC2
    runs-on: ubuntu-latest
    needs: terraform-deploy
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get SonarQube EC2 Public IP
        id: ec2-info
        run: |
          EC2_IP="18.210.3.140"
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "‚úÖ SonarQube EC2 IP: $EC2_IP"

      - name: Install SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.ec2-info.outputs.ec2_ip }} >> ~/.ssh/known_hosts

      - name: Wait for EC2 to be accessible via SSH
        run: |
          echo "‚è≥ Waiting for EC2 to be accessible via SSH..."
          for i in {1..30}; do
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} "echo 'SSH connection successful'"; then
              echo "‚úÖ EC2 is accessible via SSH"
              break
            fi
            echo "Attempt $i/30: Waiting for SSH..."
            sleep 10
          done

      - name: Install Docker, Docker Compose and Run SonarQube
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          
          echo "üì¶ Updating system packages..."
          sudo apt update
          sudo apt upgrade -y
          
          echo "üê≥ Installing Docker..."
          sudo apt install docker.io -y
          echo "‚úÖ Docker installed"
          
          echo "üê≥ Installing Docker Compose..."
          sudo apt install docker-compose -y
          echo "‚úÖ Docker Compose installed"
          
          echo "üë§ Adding ubuntu user to docker group..."
          sudo usermod -aG docker ubuntu
          
          echo "üë§ Adding jenkins user to docker group..."
          sudo usermod -aG docker jenkins || true
          
          echo "üöÄ Enabling and starting Docker service..."
          sudo systemctl enable docker
          sudo systemctl start docker
          
          echo "‚è≥ Waiting for Docker to be ready..."
          sleep 10
          sudo docker run -itd --name sonarqube-server -p 9000:9000 sonarqube:latest
          
          echo "‚è≥ Waiting for SonarQube to initialize (2-5 minutes)..."
          sleep 30
          sudo docker ps | grep sonarqube-server
          
          
          EOF

  # ============== APPLICATION DEPLOYMENT ==============

  deploy-application:
    name: Deploy Application
    runs-on: ubuntu-latest
    needs: terraform-deploy
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials with OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get EC2 Public IP
        id: ec2-info
        run: |
          EC2_IP=$(aws ec2 describe-addresses \
            --allocation-ids ${{ needs.terraform-deploy.outputs.elastic_ip }} \
            --region ${{ env.AWS_REGION }} \
            --query 'Addresses[0].PublicIp' \
            --output text)
          echo "ec2_ip=$EC2_IP" >> $GITHUB_OUTPUT
          echo "EC2 Public IP: $EC2_IP"

      - name: Install SSH Key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.ec2-info.outputs.ec2_ip }} >> ~/.ssh/known_hosts

      - name: Wait for EC2 to be accessible via SSH
        run: |
          echo "‚è≥ Waiting for EC2 to be accessible via SSH..."
          for i in {1..30}; do
            if ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} "echo 'SSH connection successful'"; then
              echo "‚úÖ EC2 is accessible via SSH"
              break
            fi
            echo "Attempt $i/30: Waiting for SSH..."
            sleep 10
          done

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image to ECR
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          file: ./frontend/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
            ${{ steps.login-ecr.outputs.registry }}/cn-web:${{ github.sha }}

      - name: SonarQube Code Analysis
        run: |
          echo "üîç Running SonarQube code analysis..."
          
          # Download SonarScanner
          mkdir -p ~/sonar-scanner
          cd ~/sonar-scanner
          wget -q https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-4.8.0.2856-linux.zip
          unzip -q sonar-scanner-cli-4.8.0.2856-linux.zip
          
          # Run SonarQube scan
          export PATH="$PATH:$(pwd)/sonar-scanner-4.8.0.2856-linux/bin"
          
          cd ${{ github.workspace }}
          
          sonar-scanner \
            -Dsonar.projectKey=wanderlust \
            -Dsonar.projectName=Wanderlust \
            -Dsonar.sources=. \
            -Dsonar.host.url=${{ secrets.SONARQUBE_HOST_URL }} \
            -Dsonar.login=${{ secrets.SONARQUBE_TOKEN }} \
            -Dsonar.qualitygate.wait=true \
            || echo "‚ö†Ô∏è SonarQube scan completed with warnings"
          
          echo "‚úÖ SonarQube analysis completed"

      - name: Verify Docker Installation
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "‚è≥ Waiting for Docker installation to complete..."
          max_attempts=30
          attempt=0
          while ! docker --version && [ $attempt -lt $max_attempts ]; do
            echo "Attempt $((attempt+1))/$max_attempts: Docker not ready yet..."
            sleep 10
            attempt=$((attempt+1))
          done
          if docker --version; then
            echo "‚úÖ Docker is installed: $(docker --version)"
          else
            echo "‚ùå Docker installation timeout"
            exit 1
          fi
          EOF

      - name: Pull and Run Docker Image from ECR
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "üîê Logging in to AWS ECR..."
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}
          echo "üê≥ Pulling Docker image from ECR..."
          docker pull ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
          echo "‚èπÔ∏è Stopping any existing containers..."
          docker stop cn-web-app 2>/dev/null || true
          docker rm cn-web-app 2>/dev/null || true
          echo "üöÄ Starting application from ECR image..."
          docker run -d --name cn-web-app -p 5173:5173 ${{ steps.login-ecr.outputs.registry }}/cn-web:latest
          echo "‚è≥ Waiting for application to be ready..."
          sleep 15
          if docker ps | grep -q cn-web-app; then
            echo "‚úÖ Application started successfully"
            docker ps | grep cn-web-app
          else
            echo "‚ùå Application failed to start"
            docker logs cn-web-app
            exit 1
          fi
          EOF

      - name: Scan Docker Image with Trivy
        run: |
          ssh -o ConnectTimeout=60 -o ServerAliveInterval=60 -o ServerAliveCountMax=5 ubuntu@${{ steps.ec2-info.outputs.ec2_ip }} << 'EOF'
          echo "üîç Scanning Docker image for vulnerabilities..."
          
          IMAGE_NAME="${{ steps.login-ecr.outputs.registry }}/cn-web:latest"
          
          echo "üì¶ Scanning image: $IMAGE_NAME"
          echo "‚è≥ This may take a few minutes on first run..."
          docker run --rm -v /var/run/docker.sock:/var/run/docker.sock aquasec/trivy:latest image --scanners vuln --severity HIGH,CRITICAL --timeout 10m $IMAGE_NAME || true
          echo "‚úÖ Image scan completed"
          EOF

      - name: Generate Deployment Summary
        id: summary
        run: |
          cat > deployment-summary.txt << EOF
          ================================================
          üéâ DEPLOYMENT COMPLETED SUCCESSFULLY üéâ
          ================================================
          
          üìä INFRASTRUCTURE DETAILS
          ‚îú‚îÄ Instance ID: ${{ needs.terraform-deploy.outputs.instance_id }}
          ‚îú‚îÄ Elastic IP Allocation: ${{ needs.terraform-deploy.outputs.elastic_ip }}
          ‚îî‚îÄ Region: ${{ env.AWS_REGION }}
          
          üåê APPLICATION ACCESS
          ‚îú‚îÄ Website URL: http://${{ steps.ec2-info.outputs.ec2_ip }}:5173
          ‚îú‚îÄ SSH Access: ssh -i <your-key.pem> ubuntu@${{ steps.ec2-info.outputs.ec2_ip }}
          ‚îî‚îÄ Status: ‚úÖ Running
          
          üìù REPOSITORY
          ‚îú‚îÄ Cloned from: https://github.com/CloudNexus-Org/CN-Web
          ‚îú‚îÄ Branch: main
          ‚îî‚îÄ Location: /home/ubuntu/app/CN-Web
          
          üê≥ CONTAINER STATUS
          ‚îú‚îÄ Docker: ‚úÖ Installed
          ‚îú‚îÄ Docker Compose: ‚úÖ Installed
          ‚îú‚îÄ Application: ‚úÖ Running
          ‚îî‚îÄ Port: 5173
          
          ‚è±Ô∏è  DEPLOYMENT TIME: $(date)
          ================================================
          
          üöÄ NEXT STEPS:
          1. Access your application at: http://${{ steps.ec2-info.outputs.ec2_ip }}:5173
          2. SSH into instance: ssh -i <your-key.pem> ubuntu@${{ steps.ec2-info.outputs.ec2_ip }}
          3. View logs: docker-compose logs -f
          4. Stop application: docker-compose down
          
          ================================================
          EOF
          cat deployment-summary.txt

      - name: Upload Deployment Summary
        uses: actions/upload-artifact@v4
        with:
          name: deployment-summary
          path: deployment-summary.txt

  # ============== CLEANUP RESOURCES ==============